<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Virtual Raster Memory Management</title>
        <link rel="stylesheet" href="css/text.css" />
        <link rel="stylesheet" href="css/layout.css" />
    </head>


    <body>
        <div id="notescontainer">
            <div id="notesheader">
                <ul class="link-bar">
                    <li> <a href="https://gwlucastrig.github.io/gridfour/">Home</a> </li>
                    <li>|</li>
                    <li><a href="https://github.com/gwlucastrig/gridfour">Code (Github)</a></li>
                    <li>|</li>
                    <li><a href="https://gwlucastrig.github.io/GridfourDocs/notes/index.html">Application Notes</a></li>
                    <li>|</li>
                </ul>
                <p>&nbsp;</p>
            </div>

            <div id="notescontent">

                <div class="titleblock">
                    <p class="blocktitle">
                        Managing a Virtual Raster<br>using a Tile-Cache Algorithm
                    </p>
                    <p class="blockauthor">by G.W. Lucas</p>
                </div>

                <h1>Introduction</h1>

                <p>
                    The Gridfour virtual raster management system provides a way to reduce the memory required for
                    processing large and very large grid-based data sets. To do so, it divides the
                    overall raster into smaller pieces (tiles) that can be swapped between memory and
                    a large-capacity storage device such as a disk drive or Solid State Drive (SSD).
                    When an application requires access to a particular part of the
                    overall grid, that subsection is read into memory for processing, then discarded or written back
                    to the supporting storage system when no longer needed. This approach is similar to the classic
                    <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual memory technique</a>.
                    It represents a compromise between performance
                    and available resources. Memory provides rapid access to data, but may be limited in size
                    or needed for other uses. File-based storage is slower than memory, but provides
                    much more capacity for storing data. The Gridfour virtual raster algorithm attempts
                    to balance these two considerations.</p>

                <p>Because reading and writing data to a high capacity storage device entails a substantial
                    performance cost, a virtual raster system requires a mechanism for managing the
                    exchange of data efficiently.  The decision of when to load or discard a particular
                    subsection of the grid should be based on the patterns-of-access for the calling
                    application and should attempt to minimize the frequency with which data is
                    transferred between memory and backing storage.</p>

                <p>In Gridfour, the exchange of raster subsections (tiles) is managed using a <i>tile-caching</i>
                    algorithm. Details of this algorithm are descibed below.</p>


                <h1>Concepts</h1>
                <h2>Raster data</h2>
                <p>
                    In computer programming, the term <i>raster</i> refers to any grid-based data set. There are
                    many different kinds of raster products. The most common kind of raster is a digital image.
                    A digital image is essentially a grid of data cells (pixels) each of which is assigned
                    a numerical value, usually light or color intensity codes.
                    But raster products also include mathematical objects such as matrices
                    and geospatial grid products such as elevation data sets.
                </p>

                <h2>The tiling scheme</h2>

                <p>The basic idea of tiling a grid can be seen in the image below. In this case,
                    a grid consisting of six rows and nine columns is divided into six 3-by-3 tiles.</p>


                <figure>
                    <img src="images/General/TilingScheme.png">
                    <figcaption>Figure 1 &ndash; A tiling scheme divides a master grid into uniformly sized sub-gribs.</figcaption>
                </figure>

                <p>The size of tiles is arbitrary. The Gridfour software libraries assume that all tiles must be of
                    a uniform size, though other APIs may use non-uniform specifications.
                    Applications are free to specify tile sizes according
                    to their needs. In this case,
                    a 2-by-9 tiling scheme would have worked just fine. In fact, a 4-by-5 tile size would
                    also work, even though the tiles would not evenly divide
                    the 6-by-9 master grid. The Gridfour APIs handle any extra cells
                    internally and their management is transparent to the application.</p>

                <h2>The tile cache</h2>
                <p>
                    When an entire grid is too large to be maintained in memory, a caching mechanism may implement
                    a strategy for keeping the data that is most likely to be needed while deferring access
                    to that part of the grid that is not immediately required. The Gridfour strategy is based on the
                    assumption that when an application accesses one cell in a grid, there is a high probability
                    that the next access will be to another cell in the proximity of the first. And, in many cases,
                    the subsequent access of grid cells occur within the bounds of a single tile. This assumption
                    is often applicable whether a raster product has a spatial basis (geophysical data)
                    or not (image data, matrices).
                </p>
                <p>Following that assumption, the tile cache is organized as a priority queue ordered by
                    the time of most recent access. The most recently accessed tiles are placed at the head of the queue.
                    The least recently accessed are placed toward its back. The queue is configured to hold an
                    arbitrary maximum number of tiles based on the desired memory use for an application. Figure 1 below shows an example
                    of a virtual raster consisting of a set of 3 rows and 3 columns of tiles. For purposes of
                    illustration, the tile cache is configured to store a maximum of 3 tiles.
                </p>
                <figure>
                    <img src="VirtualRaster_files/cache.png">
                    <figcaption>Figure 1 &ndash; A virtual raster and an empty tile cache.</figcaption>
                </figure>

                <p>
                    The design of the cache algorithm is based on the assumption that memory is limited
                    and that there is a significant performance cost in reading a tile from the
                    associated high-capacity storage device. So the primary objective of the cache
                    is to minimize redundant access to the backing storage device and to
                    to provide a high likelihood that when a particular tile is needed,
                    it will already be in memory. To address these goals
                    the tile-cache algorithm applies the following steps:</p>
                <ol>
                    <li>Identify the required tile based on the grid row and column indices to the desired data cell.</li>
                    <li>Search the tile-cache queue to determine whether the target tile is already in the cache.</li>
                    <li>If the tile is already in the cache:
                        <ol style="list-style-type:lower-alpha">
                            <li>Move the tile to the first position in the queue.</li>
                            <li>All other tiles are shifted to the right.</li>
                        </ol>
                    </li>
                    <li>If the tile is not in the cache:
                        <ol style="list-style-type:lower-alpha">
                            <li>If the cache is full, discard the rightmost tile to make room for the target tile.</li>
                            <li>Read the target tile from the backing storage device (<i>i.e.</i> a file)
                                and insert at the head of the queue.</li>
                            <li>All other tiles are shifted to the right.</li>
                        </ol>
                    </li>
                </ol>

                <p>
                    The figure below illustrates the state of the tile cache over the course of three
                    subsequent accesses to tiles A, B, and C.
                    At the end of the sequence, the least-recently accessed tile, tile A, is shifted
                    to the last (rightmost) position in the queue.</p>

                <figure>
                    <img src="VirtualRaster_files/cacheA.png">
                    <figcaption>Figure 2&ndash; The cache, after inserting tiles A, B, and C.</figcaption>
                </figure>

                <p>If the application were to access tile A again, it would be moved to the head of the queue.
                    Tiles C and B would be shifted to the right. Tile B, being the least-recently accessed tile,
                    would be shifted to the last position in the queue. The figure below illustrates what happens
                    when the application accesses an additional tile, D. Because tile B was the least-recently
                    accessed tile, it would be discarded (or written to the backing store).
                    The resulting cache would include tiles in the order D, A, and C,
                    as shown in the figure below.</p>
                <figure>
                    <img src="VirtualRaster_files/cacheACB.png">
                    <figcaption>Figure 3 &ndash; The cache, after accessing tile A and inserting tile D.</figcaption>
                </figure>

                <h2>Cache size and performance</h2>
                <p>An optimal selection of cache depends on two factors: the amount of memory that
                    an application can allocate to the tile cache, and the anticipated pattern of access.
                    Naturally, the tile cache provides an advantage when an application makes repeated accesses to
                    tiles that are already loaded the cache.</p>
                <p>The following use cases indicate different conditions under which the tile cache
                    size may be configured to support the behavior of an application:</p>
                <ol>
                    <li><b>The application accesses the grid in random
                            or widely scattered positions:</b> Most operations will require reading a new tile from the backing storage device.
                        In such cases, the tile cache does not improve performance. A smaller cache
                        size is preferred.</li>
                    <li><b>The access sequence follows a multi-cell path across the grid:</b> As an example, consider the case where a geospatial data
                        set such as elevation and bathymetry grid is tied to the path of a vehicle (aircraft, ship, etc.). Access might alternate between
                        adjacent tiles while gradually transitioning to different tiles as the vehicle moves across the region
                        supported by the raster product.  A medium size cache would perform well.</li>
                    <li><b>An application scans the entire grid in row-major order:</b> This use case is common in image processing or data-transcription
                        operations. Each scan of a grid row will cross an entire row of tiles.  So there is an advantage in making
                        the tile cache large enough to hold a complete row of tiles.  During processing, the set of tiles in the cache will
                        be accessed multiple times. But, they will only be read from the backing storage device once. Redundant tile-read operations will be eliminated. Maintaining an entire row of tiles leads
                        to a larger cache size, but the performance gain is significant.</li>
                </ol>


                <h1>Implementation</h1>
                <p>The Gridfour Software Project includes implementations of the tile cache in the Java and C programming languages.
                    Both implementations are similar in their structure and approach. These notes will focus on the C implementation.</p>
                <h2>The tile index</h2>
                <p>The Gridfour API assigns integer codes to each tile in row-major order. The first tile in the first
                    row of tiles is assigned the value zero. The tile to its right is assigned a value of one, and so forth.
                    The tile index is used as primary key for identifying tiles in all of the data collections
                    used to support the tile cache.</p>
                <h2>The tile queue implemented as a linked list</h2>
                <p>The tile queue is implemented using a doubly linked list. The tile cache maintains pointers
                    to both the head and tail of the linked list. The doubly linked list structure provides a
                    convenient way for the cache to move a tile to the head of queue when it is accessed by the application code.
                    And because the API can access the linked list from its tail end, the list-based implementation allows
                    the code to identify the least-recently used tile and discard it when the application
                    needs to insert a new tile into the queue.</p>

                <h2>A hash table expedites searching the queue</h2>
                <p>When the application requires access to a tile, it could perform a sequential search of the
                    tile queue. However, if the queue is configured to hold a large number of tiles, there could be a significant
                    performance cost for the search. To expedite tile searches, the Gridfour API implements a hash table
                    that maps a tile index to a node within the linked list. The table is implemented using an integer hash key
                    which is computed directly from the tile index. For the Gridfour C implementation, a simple hash table
                    is implemented in custom code.</p>
                <p>Note that operations on the hash table and linked list structures must be coordinated. When a tile is
                    added or removed from the list, it must also be added or removed from the hash table.
                    On the other hand, moving a tile to the front of the list does not require a change to
                    the hash table. Changing the order of tiles within a linked list is accomplished by modifying
                    the list's link elements. But the tiles themselves are not modified and their location
                    in memory does not change. Thus the corresponding tile-reference (or pointer) in the hash
                    table does not have to be adjusted.</p>

                <h1>Conclusion</h1>
                <p>The tile cache concept plays a key role in both the original
                    <a href="https://github.com/gwlucastrig/gridfour">Gridfour Java</a> and newer
                    <a href="https://github.com/gwlucastrig/GridfourC">Gridfour C</a> software libraries.
                    The source code for these projects provides examples of tile cache implementations.
                    In both cases, the code includes small enhancements that were not described in this
                    article because they are specific to the programming language used for the implementation.
                    Developers wishing to create their own versions of a tile cache may find these elements worth review.
                </p>

            </div>
        </div>
    </body>

</html>